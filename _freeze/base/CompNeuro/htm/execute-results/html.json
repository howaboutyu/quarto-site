{
  "hash": "4a947bf4d3df2349bcb674ec3cc7ef0a",
  "result": {
    "markdown": "---\ntitle: Computation neural science\nformat: html\nreference-location: margin\nbibliography: ../../references.bib\nhtml-math-method: katex\neditor:\n  render-on-save: true\n---\n\n## HTM School\n\nThis is a collection of notes - with some python demos - presented by Matt Taylor. The videos are available on YouTube and are a great way to learn about HTM. \n\n\n\n\n\n\n\n[Video playlist](https://www.youtube.com/watch?v=XMB0ri4qgwc&list=PL3yXMgtrZmDqhsFQzwUC9V8MeeVOQ7eZ9&index=2&ab_channel=Numenta)\n\n# Introduction\n#### Bit Arrays \n\nA bit array is a collection of bits, each of which can be either 0 or 1. \n\n::: {.callout-note collapse=\"true\"}\n# Hamming weight\n\nThe number of 1s in a bit array is called the Hamming weight.\n:::\n\n\nFor a bit array with 256 places, the capacity is $2^{256}$, which is a very large number. Sparsity is the fraction of 1s in the array. HTM deals with the sparsity of around 2%.\n\n#### Sparse Distributed Representation (SDR)\nThe SDR capacity is defined as #bits!/(#number on bits)!(#number off bits)!\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport math\n\ndef sdr_capacity(num_bits, on_bits):\n  print(f'sparsity : {on_bits*100./num_bits} %')\n  return math.factorial(num_bits) / (math.factorial(on_bits) * math.factorial(num_bits - on_bits))\n\n\nn=256\non_bits = 5\nprint(f'Capcity for SDR with n={16} #onbits={on_bits}: {sdr_capacity(n, on_bits)}')\n\nn=256\non_bits = 10\nprint(f'Capcity for SDR with n={16} #onbits={on_bits}: {sdr_capacity(n, on_bits)}')\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsparsity : 1.953125 %\nCapcity for SDR with n=16 #onbits=5: 8809549056.0\nsparsity : 3.90625 %\nCapcity for SDR with n=16 #onbits=10: 2.788262146425184e+17\n```\n:::\n:::\n\n\nThe capcity of a SDR is very large, and grows very fast with the number of on bits.\n\n### Overlap\nIf we have an SDR with 2048 bits and 41 on bits, and we apply noise to it, we can still find the overlap between the original SDR and the noisy SDR.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\ndef random_sdr(num_bits, on_bits):\n  print(f'Creating random sdr with sparsity: {on_bits/num_bits}')\n  sdr = [0]*num_bits\n  for i in range(on_bits):\n    sdr[np.random.randint(0,num_bits)] = 1\n  return sdr\n\ndef apply_noise(sdr, noise):\n  # each on bit has a change to be another bit\n  sdr_copy = sdr.copy()\n  for i in range(len(sdr)):\n    if sdr[i] == 1 and np.random.random() < noise:\n      sdr_copy[i] = 0\n      sdr_copy[np.random.randint(0,len(sdr))] = 1\n  return sdr_copy\n\ndef find_overlap(sdr1, sdr2):\n  overlap = 0\n  for i in range(len(sdr1)):\n    if sdr1[i] == 1 and sdr2[i] == 1:\n      overlap += 1\n  return overlap\nsdr = random_sdr(2048, 41)\nsdr_noise = apply_noise(sdr, 0.30)\n\nprint(f'Hamming weight of sdr: {sum(sdr)}')\nprint(f'Hamming weight of sdr_noise: {sum(sdr_noise)}')\n\nprint(f'Overlap of sdr and sdr_noise: {find_overlap(sdr, sdr_noise)}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCreating random sdr with sparsity: 0.02001953125\nHamming weight of sdr: 40\nHamming weight of sdr_noise: 40\nOverlap of sdr and sdr_noise: 27\n```\n:::\n:::\n\n\nTheta $\\theta$ is the threshold for the overlap. If the overlap is greater than $\\theta$, then the SDRs are considered to be similar.\n\nThe overlap is 30, and the chance of a false positive is extremely low. Thus SDR can handle noise very well.\n\n#### SDR compression\nThe SDR can be compressed by simply returning the indices of the on bits.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef sdr_to_indices(sdr):\n  indices = np.where(np.array(sdr) == 1)[0]\n  return indices\n\ndef indices_to_sdr(indices, num_bits):\n  sdr = np.zeros(num_bits)\n  sdr[indices] = 1\n  return sdr\n\nsdr = random_sdr(16, 3)\nindices = sdr_to_indices(sdr)\nprint(f'SDR: {sdr}')\nprint(f'Indices: {indices}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCreating random sdr with sparsity: 0.1875\nSDR: [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nIndices: [4 5]\n```\n:::\n:::\n\n\n### Overlap set\n\nThe overlap set $\\Omega(n, w, b)$ is the set of all SDRs between SDR with $n$ bits, $w_x$ on bits, and $w$ on bits with $b$ required overlap bits. The length of the overlap set is $C(w_x, b)C(n-w_x, w-b)$.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef combination(n, k):\n  return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\ndef len_overlap_set(n, wx, w, b):\n  len_set = combination(wx, b) * combination(n-wx, w-b) \n  chance_of_false_positive = len_set / combination(n, w)\n  print(f'Chance of false positive: {chance_of_false_positive}')\n  return len_set \n\nn=2048\nwx=40\nw=40\nb=30\nprint(f'n={n}, wx={wx}, w={w}, b={b}')\nprint(f'Overlap set length: {len_overlap_set(n, wx, w, b)} ')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nn=2048, wx=40, w=40, b=30\nChance of false positive: 1.0262987550838283e-49\nOverlap set length: 2.434153333836206e+35 \n```\n:::\n:::\n\n\n### SDR subsampling\n\nSince SDRs are so tolerant to noise, it is possible to take only a subset of the SDRs and still have a high chance of finding the correct SDR.\n\n",
    "supporting": [
      "htm_files"
    ],
    "filters": [],
    "includes": {}
  }
}