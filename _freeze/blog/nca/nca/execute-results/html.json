{
  "hash": "2aa75cd85977711b89971f0291f6cf70",
  "result": {
    "markdown": "---\ntitle: neural cellular automata\nformat: html\nreference-location: margin\nbibliography: ../../references.bib\nhtml-math-method: katex\neditor:\n  render-on-save: true\n---\n\n## Introduction \n\nWhen I first read the distil Neural Cellular Automata paper [@mordvintsev2020growing], I was introduced to and intrigued by morphogenesis - the study of how organisms grow and develop. And i though I would try to implement the NCA algorithm in Jax to play around with it.\n\n### Perception module \n\nIn real-life, only chemical gradients guide organism development. In the perception module, the NCA algorithm takes the input cell states and applies the Sobel operator for each channel in both the $x$ and $y$ directions, which is then concatenated with the original cell state. Where the cell state is a 16 dimension vector, so after the perception module, the cell state is a 48 dimension vector. \n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport sys\nsys.path.append('NCA')\n\nimport NCA.nca.model as model\nimport NCA.nca.nca as nca\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nemoji_path = 'NCA/emoji_imgs/smile.png'\n\nimg = cv2.imread(emoji_path, -1)\n\n# mult by alpha\nimg_alpha = img[:,:,3] > 0\nimg = img[:,:,:3] * img_alpha[:,:,None]\nimg = img.astype(np.uint8)\n\nimg = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\nimg = cv2.resize(img, (32,32))\n\nkernel_x, kernel_y = nca.create_perception_kernel(input_size=3, output_size=3)\n\n\n\n# transpose img into CHW \nimg = np.expand_dims(img, axis=0)/255.\nimg_t = img.transpose(0,3,1,2)\n\nperceive_out = nca.perceive(img_t, kernel_x, kernel_y) * 255\n\n# transpose back to NHWC\nperceive_out = perceive_out.transpose(0,2,3,1).astype(np.uint8) \n\nrgb = perceive_out[0,:,:,0:3]\nsobel_x = perceive_out[0,:,:,3:4]\nsobel_y = perceive_out[0,:,:,6:7]\n\n# Plot the img and the sobel imgs in x and y\nfig, axs = plt.subplots(1, 3, figsize=(15, 15))\naxs[0].imshow(rgb)\naxs[1].imshow(sobel_x[:,:,0], cmap='gray')\naxs[2].imshow(sobel_y[:,:,0], cmap='gray')\n\n# add some captions\naxs[0].set_title('RGB')\naxs[1].set_title('Sobel X')\naxs[2].set_title('Sobel Y')\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](nca_files/figure-html/cell-2-output-1.png){width=1162 height=390}\n:::\n:::\n\n\n### The update module\n\nThe update module is a simple MLP that acts on the perception vector, it only has 8,000 paramters! The state update rule can be written as:\n\n$$\n\\begin{align}\n\\mathbf{S}_{t+1} &= \\mathbf{S}_t + \\mathbf{U}(\\mathbf{S}_t) \\Delta t \\\\\n\\end{align}\n$$\n\n#### Stochastic update\n\nTo mimic the stochasticity of real-life, the update module is applied to the cell state with a probability of $p$.\n\nLet us visualise this, with $p=0.5$:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\n# create a random state\n\np = 0.5\nrandom_state = np.random.uniform(0., 1., size=rgb.shape[:2]) \n\nrgb = np.asarray(rgb)\nrgb_random_update = rgb.copy()\n\n#print(f'random state shape : {random_state.shape}')\n#print(f'rgb shape : {rgb.shape}')\n\nrgb_random_update[random_state < p] = (255, 0, 125)\n\n\n# just draw the random state ontop of the smiley\n\nfig, axs = plt.subplots(1, 2, figsize=(15, 15))\naxs[0].imshow(rgb)\naxs[1].imshow(rgb_random_update)\naxs[0].set_title('RGB')\naxs[1].set_title('RGB with random update p=0.5')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](nca_files/figure-html/cell-3-output-1.png){width=1162 height=569}\n:::\n:::\n\n\n#rgb_random_update[random_state > p] = (255, 0, 125)\n\n#### Living cell update\n\nA cell is \"empty\" if all cells in a 3x3 neighbourhood are empty. If a cell is not empty, it is a \"living cell\". The update module is only applied to living cells. To do this we can using a max-pooling operation with a window size of 3x3 and stride of 1x1. We can use `lax.reduce_window` to do this. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport jax\ndef max_pool(x, window_shape, strides):\n    # x is HWC\n    return jax.lax.reduce_window(\n        x, \n        -np.inf, \n        jax.lax.max, \n        window_strides=strides, \n        window_dimensions=window_shape,\n        padding=\"SAME\"\n        )\n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\n# create random living cell states\nrandom_living_states = np.random.uniform(0., 1., size=rgb.shape[:2]) \nprint(f'random_living_states : {random_living_states.shape}')\n#random_living_states_t = random_living_states.transpose(2,0,1)\n#\n#\n## apply max pooling to get the living cell states\n#living_states = max_pool(random_living_states_t, (1,3,3), (1,1,1))\n#living_states = living_states.transpose(1,2,0)\n#living_states = np.asarray(living_states).astype(np.uint8)\n#\n## plot it\n#fig, axs = plt.subplots(1, 2, figsize=(15, 15))\n#axs[0].imshow(random_living_states)\n#axs[1].imshow(living_states)\n#axs[0].set_title('Random living states')\n#axs[1].set_title('Max-pooled living states')\n#plt.show()\n#\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrandom_living_states : (32, 32)\n```\n:::\n:::\n\n\n* Michale Levin and Lex Fridman's podcast [yt link](https://www.youtube.com/watch?v=p3lsYlod5OU&ab_channel=LexFridman)\n\n",
    "supporting": [
      "nca_files"
    ],
    "filters": [],
    "includes": {}
  }
}