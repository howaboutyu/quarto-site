

---
title: Computation neural science 
format: html
reference-location: margin
jupyter: python3
bibliography: ../../references.bib
html-math-method: katex
editor:
  render-on-save: true

---

## Chapter 2: The neuron and minimal spiking models

### Tutorial 2.1: The leaky integrate-and-fire neuron model

::: {.callout-note data-latex=""}
# Tutorial goal
To understand the basic properties of the leaky integrate-and-fire (LIF) neuron model and how noise causes the smoothing of f-I curves.
:::

The LIF model is given by the following equation: 

$$C_m \frac{dV_m}{dt} = (E_L - V_m)/R_m + I_{app}   $$

with the condition $\quad V_m > V_{th}$ then $V_m \rightarrow V_{reset}$

in this tutorial, we are using the following parameters: 

```{python}

C_m = 2.e-9
E_L = -70.e-3 # leak reversal potential
E_K = -80e-3
R_m = 5.e6
G_L = 1./R_m
V_th = -50.e-3
V_reset = -65.e-3

tau_m = C_m/G_L

dt = 0.1e-3
```




```{python}
#| code-fold: true

import numpy as np




times = np.arange(0, 200.e-3, dt)
V = np.zeros_like(times)

I_th = G_L*(V_th - E_L)
I = np.ones_like(times) * I_th 

V[0] = E_L

def dvdt(V_m, I_app, G_ref=None):
    value = (E_L - V_m)/R_m + I_app 
    if G_ref is not None:
        value = value + G_ref* (E_K- V_m)
    value = value/C_m
    return value


def simulate(V, I, noises=None, tau_ref=None, tau_vth=None, V_th_array=None, G_ref=None, tau_Gref=None):
    num_fire = 0
    last_fire_time = -100

    dvthdt_array = []
    for i in range(1, len(times)):
        if G_ref is None:
            V_new = V[i-1] + dvdt(V[i-1], I[i-1]) * dt
        else:
            V_new = V[i-1] + dvdt(V[i-1], I[i-1], G_ref[i-1]) * dt
                
        if tau_vth is not None:
            dvthdt = (-50e-3 - V_th_array[i-i]) / tau_vth
            dvthdt_array.append(V_th_array[i-i])
            V_th_array[i] = V_th_array[i-1] + dt*dvthdt
        
        if G_ref is not None:            
            dG_refdt = -G_ref[i-1]/tau_Gref
            G_ref[i] = G_ref[i-1] + dt * dG_refdt

        if tau_vth is not None:
            
            if V_new > V_th_array[i-1]:  # Fire
                V_new = V_reset
                num_fire += 1
                
                V_th_array[i-1] = 200e-3
                
                if G_ref is not None: 
                    
                    G_ref[i] =G_ref[i]+ 2e-6
                                   
        else:
            if V_new > V_th: 

                V_new = V_reset
                num_fire += 1
                last_fire_time = times[i]
        
        if noises is not None:
            V_new += noises[i]
        
        if tau_ref is not None:
            if times[i] - last_fire_time < tau_ref:
                V_new = V_reset
        
        V[i] = V_new
    
    fire_rate = num_fire/(times[-1] - times[0])
    
    if tau_vth is not None:
        return fire_rate, dvthdt_array
    return fire_rate

```
#### Threshold current
We can find the threshold current $I_{th}$ by setting $dV/dt$ of *LLF* equation to $0$, giving the following equation: 
$$I_{th} = G_L(V_{th} - E_L)$$

Which is 

```{python}
#| code-fold: true
I_th = G_L * (V_th - E_L)
print(f'I_th : {I_th}')
```


In the plots below, the equation for the current threshold is validated; we can see that for 1% below the threshold current $I_{th}$ no spikes are generated, but when increased to higher than the threshold current, spikes can be seen.

```{python}    
#| code-fold: true
import matplotlib.pyplot as plt
import numpy as np
import plotly.express as px
from plotly.subplots import make_subplots
import plotly.graph_objects as go

V_1 = np.copy(V)
V_2 = np.copy(V)
fr1 = simulate(V_1, np.ones_like(V_1) * I_th*.99)
fr2 = simulate(V_2, np.ones_like(V_1) * I_th*1.01)
print(f'Firing rate for 0.99 * I_th: {fr1}')
print(f'Firing rate for 1.01 * I_th: {fr2}')

# plot

fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.02)

fig.add_trace(go.Scatter(x=times, y=V_1, name='0.99 * I_th'), row=1, col=1)

fig.add_trace(go.Scatter(x=times, y=V_2, name='1.01 * I_th'), row=2, col=1)

fig.update_layout(height=600, width=800, title_text="Voltage vs time")

# set axis names
fig.update_xaxes(title_text="time (s)", row=2, col=1)

fig.update_yaxes(title_text="Voltage (V)", row=1, col=1)
fig.update_yaxes(title_text="Voltage (V)", row=2, col=1)

fig.show()
```



The firing rate of the neuron is given by the following equation:

$$
1/f = \tau_m \ln \left(\frac{I R_m + E_L - V_{reset}}{I R_m + E_L - V_{th}}\right)
$$

Below I  plot the equation for the firing rate of the neuron using the above equation and the firing rate of the neuron using the *LLF* equation. We can see that the firing rate of the neuron is very close to the firing rate of the neuron using the *LLF* equation. We can also see that the firing rate is 0 when the current is below the threshold current $I_{th}=4nA$.


```{python}
#| code-fold: true
fr_array = []
fr_eq_array = []    
I_array = np.arange(2e-9, 1e-8, 1e-9)
def fr_func(I):
    value = tau_m * np.log(max(1e-7, I * R_m + E_L - V_reset)) - tau_m * np.log(max(1e-7, I*R_m + E_L-V_th))
    value = 1./value
    return value

for I in I_array:
    V_3 = np.copy(V)
    fr = simulate(V_3, np.ones_like(times) * I)
    #print(f'Firing rate for I = {I}: {fr}')
    fr_array.append(fr)
    fr_eq = fr_func(I)
    fr_eq_array.append(fr_eq)


# use plotly
fig = make_subplots(rows=1, cols=1, shared_xaxes=True, vertical_spacing=0.02)
fig.add_trace(go.Scatter(x=I_array, y=fr_array, name='f LLF'), row=1, col=1)
fig.add_trace(go.Scatter(x=I_array, y=fr_eq_array, name='f equation'), row=1, col=1)

fig.update_layout(height=600, width=800, title_text="f vs I")

# set axis names
fig.update_xaxes(title_text="I (A)", row=1, col=1)

fig.update_yaxes(title_text="f (Hz)", row=1, col=1)

fig.show()
```


Add a noise term for each time step.

```{python}
#| code-fold: true
V_4 = np.copy(V)

noises_fn = lambda sigma_I:  np.random.normal(size=times.shape) * sigma_I * np.sqrt(dt)
#| code-fold: true
fr_array_no_noise = []
fr_array_noise1 = []
fr_array_noise2 = []
I_array = np.arange(1e-9, 1e-8, 1e-9)


for I in I_array:
    V_3 = np.copy(V)
    noise = noises_fn(0)
    fr = simulate(V_3, np.ones_like(times) * I, noises=noise)
    fr_array_no_noise.append(fr)
    noise = noises_fn(2e-3)
    fr = simulate(V_3, np.ones_like(times) * I, noises=noise)
    fr_array_noise1.append(fr)
    noise = noises_fn(1e-2)
    fr = simulate(V_3, np.ones_like(times) * I, noises=noise)
    fr_array_noise2.append(fr)


# use plotly
fig = make_subplots(rows=1, cols=1, shared_xaxes=True, vertical_spacing=0.02)
fig.add_trace(go.Scatter(x=I_array, y=fr_array_no_noise, name='sigma_I = 0'), row=1, col=1)
fig.add_trace(go.Scatter(x=I_array, y=fr_array_noise1, name='sigma_I=2e-3'), row=1, col=1)
fig.add_trace(go.Scatter(x=I_array, y=fr_array_noise2, name='sigma_I=1e-2'), row=1, col=1)

fig.update_layout(height=600, width=800, title_text="f vs I")

# set axis names
fig.update_xaxes(title_text="I (A)", row=1, col=1)

fig.update_yaxes(title_text="f (Hz)", row=1, col=1)

fig.show()
```

As we increase $sigma_I$ - proportional to the voltage noise - the firing rate close to $I_{th}$ increases. I think this might be due to cases where the voltage is close to the threshold voltage and the noise pushes the voltage over the threshold voltage. This is a hypothesis and I am not sure if this is correct.


### Tutorial 2.2
```{python}
#| code-fold: true
C_m = 0.1e-9
E_L = -70.e-3
R_m = 100.e6
G_L = 1./R_m
V_th = -50e-3
V_reset = -65.e-3

tau_m = C_m/G_L
I_th = G_L*(V_th - E_L)

fr_array_1 = [] # Forced voltage clamp method
mean_V_1 = []

fr_array_2 = [] # Threshold increase
mean_V_2 = []

fr_array_3 = [] # Threshold increase
mean_V_3 = []
I_array = np.arange(100e-12, 600e-12, 50e-12)

for I in I_array:
    V_1 = np.copy(V)
    fr_1 = simulate(V_1, np.ones_like(times) * I, tau_ref=2.5e-3)
    fr_array_1.append(fr_1)
    mean_V_1.append(np.mean(V_1))
    
    V_2 = np.copy(V)
    V_th_array = np.zeros_like(times)
    V_th_array[0] = V_th
    fr_2,dvthdt_array = simulate(V_2, np.ones_like(times) * I, tau_vth=1e-3, V_th_array=V_th_array)
    fr_array_2.append(fr_2)
    mean_V_2.append(np.mean(V_2))
    
    
    V_3 = np.copy(V)
    V_th_array = np.zeros_like(times)
    G_ref = np.zeros_like(times)
    V_th_array[0] = V_th
    G_ref[0] = 0.
    fr_3,_ = simulate(V_3, np.ones_like(times) * I, tau_vth=1e-3, V_th_array=V_th_array, G_ref=G_ref, tau_Gref=0.2e-3)
    print(fr_3)
    fr_array_3.append(fr_3)
    mean_V_3.append(np.mean(V_3))
fig = plt.figure().suptitle('current vs fr')

plt.plot(I_array, fr_array_1, label='forced voltage clamp')
plt.plot(I_array, fr_array_2, label='threshold increase')
plt.plot(I_array, fr_array_3, label='refractory conductance')
plt.xlabel('I')
plt.ylabel('fr')
plt.legend(loc='lower right')
plt.figure().suptitle('current vs mean V')
plt.plot(I_array, mean_V_1,  label='forced voltage clamp')
plt.plot(I_array, mean_V_2, label='threshold increase')
plt.plot(I_array, mean_V_3, label='refractory')
plt.xlabel('I')
plt.ylabel('Mean V')
plt.legend(loc='lower right')
plt.figure().suptitle('  fr vs mean V')
plt.plot( fr_array_1,mean_V_1, label='forced voltage clamp')
plt.plot( fr_array_2,mean_V_2,label='threshold increase')
plt.plot( fr_array_3,mean_V_3,label='refractory')
plt.xlabel('fr')
plt.ylabel('Mean V')
plt.legend(loc='lower right')

plt.figure().suptitle('  V vst ')
plt.plot( times,V_1, label='forced voltage clamp')
#plt.plot( times,V_2,label='threshold increase')
plt.xlabel('fr')
plt.ylabel('Mean V')
plt.legend(loc='lower right') 
```